Quiet output, complete output of diff function : see below

env-15jb:~> diff -rq kpp-2.2.3/ kpp_rs/
Seulement dans kpp_rs/examples: Makefile_small_f77
Les fichiers kpp-2.2.3/int/kpp_lsode.f90 et kpp_rs/int/kpp_lsode.f90 sont différents
Les fichiers kpp-2.2.3/int/kpp_seulex.f90 et kpp_rs/int/kpp_seulex.f90 sont différents
Les fichiers kpp-2.2.3/int/rosenbrock.f et kpp_rs/int/rosenbrock.f sont différents
Les fichiers kpp-2.2.3/int/rosenbrock.f90 et kpp_rs/int/rosenbrock.f90 sont différents
Seulement dans kpp_rs/int: rosenbrock_mz.def
Seulement dans kpp_rs/int: rosenbrock_mz.f90
Seulement dans kpp_rs/int: rosenbrock_posdef.def
Seulement dans kpp_rs/int: rosenbrock_posdef.f90
Seulement dans kpp_rs/int: rosenbrock_posdef_h211b_qssa.def
Seulement dans kpp_rs/int: rosenbrock_posdef_h211b_qssa.f90
Les fichiers kpp-2.2.3/int/runge_kutta.f90 et kpp_rs/int/runge_kutta.f90 sont différents
Les fichiers kpp-2.2.3/int/sdirk.f90 et kpp_rs/int/sdirk.f90 sont différents
Seulement dans kpp-2.2.3/: int.modified_WCOPY
Les fichiers kpp-2.2.3/Makefile et kpp_rs/Makefile sont différents
Les fichiers kpp-2.2.3/Makefile.defs et kpp_rs/Makefile.defs sont différents
Seulement dans kpp_rs/: Makefile.defs.AIX
Seulement dans kpp_rs/: Makefile.defs.Darwin
Seulement dans kpp_rs/: Makefile.defs.Linux
Seulement dans kpp_rs/: Makefile.defs.OSF1
Seulement dans kpp_rs/: Makefile.m
Seulement dans kpp-2.2.3/src: code_f90.c_original
Les fichiers kpp-2.2.3/src/gdata.h et kpp_rs/src/gdata.h sont différents
Les fichiers kpp-2.2.3/src/gen.c et kpp_rs/src/gen.c sont différents
Seulement dans kpp_rs/src: lex.yy.c
Les fichiers kpp-2.2.3/src/Makefile et kpp_rs/src/Makefile sont différents
Les fichiers kpp-2.2.3/src/scan.h et kpp_rs/src/scan.h sont différents
Les fichiers kpp-2.2.3/src/scanutil.c et kpp_rs/src/scanutil.c sont différents
Les fichiers kpp-2.2.3/src/scan.y et kpp_rs/src/scan.y sont différents
Seulement dans kpp_rs/src: y.tab.c
Seulement dans kpp_rs/src: y.tab.h
Les fichiers kpp-2.2.3/util/sutil.f90 et kpp_rs/util/sutil.f90 sont différents
Les fichiers kpp-2.2.3/util/UserRateLaws.f et kpp_rs/util/UserRateLaws.f sont différents



env-15jb:~> diff -r kpp-2.2.3/ kpp_rs/

Seulement dans kpp_rs/examples: Makefile_small_f77

diff -r kpp-2.2.3/int/kpp_lsode.f90 kpp_rs/int/kpp_lsode.f90
29,39c29,37
<   ! mz_rs_20050717: TODO: use strings of IERR_NAMES for error messages
<   ! description of the error numbers IERR
<   CHARACTER(LEN=50), PARAMETER, DIMENSION(-8:1) :: IERR_NAMES = (/ &
<     'Matrix is repeatedly singular                     ', & ! -8
<     'Step size too small                               ', & ! -7
<     'No of steps exceeds maximum bound                 ', & ! -6
<     'Improper tolerance values                         ', & ! -5
<     'FacMin/FacMax/FacRej must be positive             ', & ! -4
<     'Hmin/Hmax/Hstart must be positive                 ', & ! -3
<     'Improper value for maximal no of Newton iterations', & ! -2
<     'Improper value for maximal no of steps            ', & ! -1
---
>   ! mz_rs_20070822+
>   CHARACTER(LEN=50), PARAMETER, DIMENSION(-7:1) :: IERR_NAMES = (/ &
>     'Nothing was done, because TOUT was equal to T     ', & ! -7
>     'Error weight became zero during problem           ', & ! -6
>     'Repeated convergence failures                     ', & ! -5
>     'Repeated error test failures (check all inputs)   ', & ! -4
>     'Illegal input detected (see printed message)      ', & ! -3
>     'Excess accuracy requested (tolerances too small)  ', & ! -2
>     'Excess work done on this call (perhaps wrong MF)  ', & ! -1
41a40
>   ! mz_rs_20070822-
diff -r kpp-2.2.3/int/kpp_seulex.f90 kpp_rs/int/kpp_seulex.f90
27d26
<   ! mz_rs_20050717: TODO: use strings of IERR_NAMES for error messages
29,33c28,40
<   CHARACTER(LEN=50), PARAMETER, DIMENSION(-4:1) :: IERR_NAMES = (/ &
<     'Matrix is repeatedly singular                     ', & ! -4
<     'Step size too small                               ', & ! -3
<     'More than Max_no_steps steps are needed           ', & ! -2
<     'Insufficient storage for work or iwork            ', & ! -1
---
>   CHARACTER(LEN=50), PARAMETER, DIMENSION(-12:1) :: IERR_NAMES = (/ &
>     'Matrix is repeatedly singular                     ', & ! -12
>     'Step size too small: T + 10*H = T or H < Roundoff ', & ! -11
>     'No of steps exceeds maximum bound                 ', & ! -10
>     'Improper tolerance values                         ', & ! -9
>     'FacMin/FacMax/FacRej must be positive             ', & ! -8
>     'Hmin/Hmax/Hstart must be positive                 ', & ! -7
>     'Improper parameters for second order equations    ', & ! -6
>     'Improper number of dense output components        ', & ! -5
>     'Improper value for Lambda (must be 0/1)           ', & ! -4
>     'Improper value for step size sequence             ', & ! -3
>     'Improper value for max no of cols in extrapolation', & ! -2
>     'Improper value for maximal no of steps            ', & ! -1

diff -r kpp-2.2.3/int/rosenbrock.f90 kpp_rs/int/rosenbrock.f90
30a31,43
>   ! description of the error numbers IERR
>   CHARACTER(LEN=50), PARAMETER, DIMENSION(-8:1) :: IERR_NAMES = (/ &
>     'Matrix is repeatedly singular                     ', & ! -8
>     'Step size too small                               ', & ! -7
>     'No of steps exceeds maximum bound                 ', & ! -6
>     'Improper tolerance values                         ', & ! -5
>     'FacMin/FacMax/FacRej must be positive             ', & ! -4
>     'Hmin/Hmax/Hstart must be positive                 ', & ! -3
>     'Selected Rosenbrock method not implemented        ', & ! -2
>     'Improper value for maximal no of steps            ', & ! -1
>     '                                                  ', & !  0 (not used)
>     'Success                                           ' /) !  1
> 
56,59d68
< 
<     !~~~> fine-tune the integrator:
<    ICNTRL(1) = 0	! 0 - non-autonomous, 1 - autonomous
<    ICNTRL(2) = 0	! 0 - vector tolerances, 1 - scalars
Seulement dans kpp-2.2.3/int: rosenbrock.f_original
Seulement dans kpp_rs/int: rosenbrock_mz.def
Seulement dans kpp_rs/int: rosenbrock_mz.f90
Seulement dans kpp_rs/int: rosenbrock_posdef.def
Seulement dans kpp_rs/int: rosenbrock_posdef.f90
Seulement dans kpp_rs/int: rosenbrock_posdef_h211b_qssa.def
Seulement dans kpp_rs/int: rosenbrock_posdef_h211b_qssa.f90
diff -r kpp-2.2.3/int/runge_kutta.f90 kpp_rs/int/runge_kutta.f90
32a33,50
>    ! description of the error numbers IERR
>    CHARACTER(LEN=50), PARAMETER, DIMENSION(-13:1) :: IERR_NAMES = (/ &
>      'Requested RK method not implemented               ', & ! -13
>      'Non-convergence of Newton iterations              ', & ! -12
>      'Matrix is repeatedly singular                     ', & ! -11
>      'Step size too small: T + 10*H = T or H < Roundoff ', & ! -10
>      'No of steps exceeds maximum bound                 ', & ! -9
>      'Tolerances are too small                          ', & ! -8
>      'Improper values for Qmin, Qmax                    ', & ! -7
>      'Newton stopping tolerance too small               ', & ! -6
>      'Improper value for ThetaMin                       ', & ! -5
>      'Improper values for FacMin/FacMax/FacSafe/FacRej  ', & ! -4
>      'Hmin/Hmax/Hstart must be positive                 ', & ! -3
>      'Improper value for maximal no of Newton iterations', & ! -2
>      'Improper value for maximal no of steps            ', & ! -1
>      '                                                  ', & !  0 (not used)
>      'Success                                           ' /) !  1
> 
diff -r kpp-2.2.3/int/sdirk.f90 kpp_rs/int/sdirk.f90
33a34,46
>   ! description of the error numbers IERR
>   CHARACTER(LEN=50), PARAMETER, DIMENSION(-8:1) :: IERR_NAMES = (/ &
>     'Matrix is repeatedly singular                     ', & ! -8
>     'Step size too small: T + 10*H = T or H < Roundoff ', & ! -7
>     'No of steps exceeds maximum bound                 ', & ! -6
>     'Improper tolerance values                         ', & ! -5
>     'FacMin/FacMax/FacRej must be positive             ', & ! -4
>     'Hmin/Hmax/Hstart must be positive                 ', & ! -3
>     'Improper value for maximal no of Newton iterations', & ! -2
>     'Improper value for maximal no of steps            ', & ! -1
>     '                                                  ', & !  0 (not used)
>     'Success                                           ' /) !  1
> 
61,63d73
<    !~~~> fine-tune the integrator:
<    ICNTRL(2) = 0	! 0 - vector tolerances, 1 - scalar tolerances
<    ICNTRL(6) = 0	! starting values of Newton iterations: interpolated (0), zero (1)
510c520
< 	       IF (StartNewton) THEN
---
>                IF (StartNewton) THEN
512c522
< 	       END IF
---
>                END IF
523,524c533,534
<  	    CALL WADD(N,Y,Z(1,istage),TMP)         	! TMP <- Y + Zi
<             CALL FUN_CHEM(T+rkC(istage)*H,TMP,RHS)	! RHS <- Fun(Y+Zi)
---
>             CALL WADD(N,Y,Z(1,istage),TMP)              ! TMP <- Y + Zi
>             CALL FUN_CHEM(T+rkC(istage)*H,TMP,RHS)      ! RHS <- Fun(Y+Zi)
527,528c537,538
< 	    CALL WSCAL(N, H*rkGamma, RHS, 1)
< 	    CALL WAXPY (N, -ONE, Z(1,istage), 1, RHS, 1)
---
>             CALL WSCAL(N, H*rkGamma, RHS, 1)
>             CALL WAXPY (N, -ONE, Z(1,istage), 1, RHS, 1)
635c645
< 	 
---
>          
1220d1229
<       USE KPP_ROOT_Jacobian

Seulement dans kpp-2.2.3/: int.modified_WCOPY

diff -r kpp-2.2.3/Makefile kpp_rs/Makefile
32c32,33
< include Makefile.defs
---
> SYSTEM := $(shell uname)
> include Makefile.defs.$(SYSTEM)
47d47
< 	@cd src;make maintainer-clean;cd ..
48a49,51
> 
> maintainer-clean: distclean
> 	@cd src;make maintainer-clean;cd ..

Seulement dans kpp_rs/: Makefile.defs.AIX
Seulement dans kpp_rs/: Makefile.defs.Darwin
Seulement dans kpp_rs/: Makefile.defs.Linux
Seulement dans kpp_rs/: Makefile.defs.OSF1
Seulement dans kpp_rs/: Makefile.m
diff -r kpp-2.2.3/readme kpp_rs/readme
3,4c3,5
<   KPP - symbolic chemistry Kinetics PreProcessor, Version 2.1
<         (http://www.cs.vt.edu/~asandu/Software/KPP)
---
>   KPP - symbolic chemistry Kinetics PreProcessor
>         (for version, see src/gdata.h)
>         http://www.cs.vt.edu/~asandu/Software/KPP
8c9
<     (C) 1997-2005, A. Sandu, Michigan Tech, Virginia Tech
---
>     (C) 1997-2016, A. Sandu, Michigan Tech, Virginia Tech
14c15
< To get started with KPP:  Read user's manual (doc/kpp-UserManual.pdf)
---
> To get started with KPP:  Read user's manual (doc/kpp_UserManual.pdf)
39c40
< 	export PATH=$PATH:$HOME/kpp/bin
---
> 	export PATH=${PATH}:$HOME/kpp/bin

diff -r kpp-2.2.3/src/code_f90.c kpp_rs/src/code_f90.c
39a40,42
> /* setting LEN=15 avoids problems with long species names */
> /* setting LEN=32 avoids problems with long equation tags ! mz_pj_20080716 */
> /* change in F90_DeclareData is probably also necessary */
44c47
<                     "CHARACTER(LEN=15)",  /* STRING */
---
>                     "CHARACTER(LEN=32)",  /* STRING */ /*  mz_ak_20060206 */
120c123,126
< int number_of_lines = 1, MAX_NO_OF_LINES = 36;
---
> /*  mz_rs_20151126+ */
> /* if MAX_NO_OF_LINES is too small, KPP will split lines incorrectly */
> int number_of_lines = 1, MAX_NO_OF_LINES = 250;
> /*  mz_rs_20151126- */
384c390,393
<             bprintf( "'%-15s'", cval[i] ); break;
---
>             /* setting length to 15 avoids problems with long species names */
>             /* setting length to 32 avoids problems with long equation tags */
>             /* change in "char *F90_types" is probably also necessary */
>             bprintf( "'%-32s'", cval[i] ); break; /*  mz_ak_20060206 */

diff -r kpp-2.2.3/src/gdata.h kpp_rs/src/gdata.h
32c32
< #define KPP_VERSION "2.2.3"
---
> #define KPP_VERSION "2.2.3_rs"
39,40c39,54
< #define MAX_EQN        5000
< #define MAX_SPECIES    3000
---
> /* mz_rs_20100222+ */
> /* Some hints: */
> /* - Many limits can be changed here by adjusting the MAX_* constants */
> /* - To increase the max size of inlined code (F90_GLOBAL etc.), */
> /*   change MAX_INLINE in scan.h */
> /* - To allow longer f90 expressions for the rate coefficients in the
>      eqn file, change consistently:
>      - crtToken, nextToken, crtFile, and crt_rate in scan.l
>      - MAX_K in this file
>      - union in scan.y
>      Note that MAX_EQNLEN only determines how long the printout of the
>      equation in the Monitor file will be. */
> /* mz_rs_20100222- */
> 
> #define MAX_EQN       11000 /* mz_rs_20070124 */
> #define MAX_SPECIES    3500 /* mz_ak_20060206 */
44,46c58,60
< #define MAX_EQNTAG       12
< /* MAX_K = max length of rate expression in eqn file */
< #define MAX_K           150
---
> #define MAX_EQNTAG       32 /*  mz_pj_20080716 */
> /* check if changes in code_f90.c are also necessary when changing MAX_EQNTAG */
> #define MAX_K           300 /* mz_rs_20070430 */

diff -r kpp-2.2.3/src/gen.c kpp_rs/src/gen.c
56a57,59
> /*  mz_rs_20160201+ */
> int StoichNum;
> /*  mz_rs_20160201- */
73c76
< int RTOLS, TSTART, TEND, DT;
---
> int TSTART, TEND, DT;
159a163,165
>   /*  mz_rs_20160201+ */
>   StoichNum = DefmElm( "StoichNum", real, -NVAR, -NREACT, "Stoichiometric numbers" );
>   /*  mz_rs_20160201- */
177d182
<   RTOLS  = DefElm( "RTOLS", real, "(scalar) Relative tolerance");
339d343
<   GlobalDeclare( RTOLS );
386,387c390,393
<   crow   = AllocIntegerVector( dim, "crow in GenerateMonitorData");
<   diag   = AllocIntegerVector( dim, "diag in GenerateMonitorData");
---
>   /*  mz_rs_20070126+ not used, therefore deleted */
>   /*  crow   = AllocIntegerVector( dim, "crow in GenerateMonitorData"); */
>   /*  diag   = AllocIntegerVector( dim, "diag in GenerateMonitorData"); */
>   /*  mz_rs_20070126- */
498c504,507
<   free(crow); free(diag); free(lookat); free(moni); free(trans);
---
>   /* mz_rs_20070126+ not used, therefore deleted */
>   /* free(crow); free(diag); */
>   /* mz_rs_20070126- */
>   free(lookat); free(moni); free(trans);
593a603,609
> /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
> /*  mz_rs_20160201+ */
> void GenerateStoichNum()
> {
>   int i, j, k;
>   int l, m;
>   int CalcStoichNum;
594a611,692
>   if( VarNr == 0 ) return;
>   if (useLang != MATLAB_LANG)  /* Matlab generates an additional file per function */
>     UseFile( functionFile ); 
>   CalcStoichNum = DefFnc( "CalcStoichNum", 1, "calculate stoichiometric numbers");
>   FunctionBegin( CalcStoichNum, StoichNum );
>   F90_Inline("  StoichNum(:,:) = 0.");
>   for (i = 0; i < VarNr; i++) {
>     for (j = 0; j < EqnNr; j++) {
>       if ( Stoich[i][j] != 0 )
>         Assign( Elm( StoichNum, i, j ), Const( Stoich[i][j] ));
>     }
>   }
>   FunctionEnd( CalcStoichNum );
>   FreeVariable( CalcStoichNum );
> }
> /*  mz_rs_20160201- */
> 
> /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
> /*mz_dt_20150424+ */
> void GenerateFun_Split()
> {
>   int i, j, k;
>   int used;
>   int l, m;
>   int FSPLIT_VAR;
> 
>   if( VarNr == 0 ) return;  
>   if (useLang != MATLAB_LANG)  /* Matlab generates an additional file per function */
>     UseFile( functionFile ); 
>   FSPLIT_VAR = DefFnc( "Fun_SPLIT", 5, "time derivatives of variables - Split form");
>   FunctionBegin( FSPLIT_VAR, V, F, RCT, P_VAR, D_VAR );
>   NewLines(1);
>   WriteComment("Computation of equation rates");
>   for(j=0; j<EqnNr; j++) {
>     used = 0;
>     for (i = 0; i < VarNr; i++) 
>       if ( Stoich_Right[i][j] != 0 ) { 
>         used = 1;
>         break;
>       }
>     if ( used ) {    
>       prod = RConst( j );
>       for (i = 0; i < VarNr; i++) 
>         for (k = 1; k <= (int)Stoich_Left[i][j]; k++ )
>           prod = Mul( prod, Elm( V, i ) ); 
>       for ( ; i < SpcNr; i++) 
>         for (k = 1; k <= (int)Stoich_Left[i][j]; k++ )
>           prod = Mul( prod, Elm( F, i - VarNr ) );
>       Assign( Elm( A, j ), prod );
>     }
>   }
>   NewLines(1);
>   WriteComment("Production function");
>   for (i = 0; i < VarNr; i++) {
>     sum = Const(0);
>     for (j = 0; j < EqnNr; j++) 
>       sum = Add( sum, Mul( Const( Stoich_Right[i][j] ), Elm( A, j ) ) );
>     Assign( Elm( P_VAR, i ), sum );
>   }
>   NewLines(1);
>   WriteComment("Destruction function");
>   for (i = 0; i < VarNr; i++) {
>     sum = Const(0);       
>     for(j=0; j<EqnNr; j++) {
>       if ( Stoich_Left[i][j] == 0 ) continue;
>       prod = Mul( RConst( j ), Const( Stoich_Left[i][j] ) );
>       for (l = 0; l < VarNr; l++) {
>         m=(int)Stoich_Left[l][j] - (l==i);
>         for (k = 1; k <= m; k++ )
>           prod = Mul( prod, Elm( V, l ) );
>       }     
>       for ( ; l < SpcNr; l++) 
>         for (k = 1; k <= (int)Stoich_Left[l][j]; k++ )
>           prod = Mul( prod, Elm( F, l - VarNr  ) ); 
>       sum = Add( sum, prod );
>     }
>     Assign( Elm( D_VAR, i ), sum );
>   }
>   FunctionEnd( FSPLIT_VAR );
>   FreeVariable( FSPLIT_VAR );
> }
> /*mz_dt_20150424- */
2300d2397
<   ExternDeclare( RTOLS );
2523a2621,2625
> 
>   /*  mz_rs_20151116+ */
>   F77_Inline("      INCLUDE '%s_Parameters.h'", rootFileName);
>   F90_Inline("  USE %s_Parameters\n", rootFileName);
>   /*  mz_rs_20151116- */
2869c2971,2974
<   F90_Inline("  INTEGER, PARAMETER :: dp = SELECTED_REAL_KIND(14,300)");
---
>   /*  mz_rs_20060308+ */
>   /* F90_Inline("  INTEGER, PARAMETER :: dp = SELECTED_REAL_KIND(14,300)"); */
>   F90_Inline("  INTEGER, PARAMETER :: dp = SELECTED_REAL_KIND(12,307)");
>   /*  mz_rs_20060308- */
3098c3203
<   printf("\n Unrecognized option '%s' in GenerateF90Modules\n", where);
---
>   printf("\n Unrecognized option '%c' in GenerateF90Modules\n", where);
3132c3237
<     default: printf("\n Language no '%s' unknown\n",useLang );		 
---
>     default: printf("\n Language no '%d' unknown\n",useLang );		 
3160a3266,3271
>   /*mz_dt_20150424+*/
>   GenerateFun_Split();  
>   /*mz_dt_20150424-*/
>   /*  mz_rs_20160201+ */
>   GenerateStoichNum();  
>   /*  mz_rs_20160201- */

diff -r kpp-2.2.3/src/Makefile kpp_rs/src/Makefile
32,33c32,33
< 
< include ../Makefile.defs
---
> SYSTEM := $(shell uname)
> include ../Makefile.defs.$(SYSTEM)
39a40,48
> # list the configuration:
> .PHONY: list
> list:
> 	@echo "SYSTEM       = $(SYSTEM)"
> 	@echo "CC           = $(CC)"
> 	@echo "FLEX         = $(FLEX)"
> 	@echo "FLEX_LIB_DIR = $(FLEX_LIB_DIR)"
> 	@echo "CC_FLAGS     = $(CC_FLAGS)"
> 
42c51
< 	@$(CC) $(CC_FLAGS) $(CFLAGS) -I$(INCLUDE_DIR) -c $*.c
---
> 	@$(CC) $(CC_FLAGS) $(CFLAGS) -c $*.c
diff -r kpp-2.2.3/src/scan.h kpp_rs/src/scan.h
40,41c40,41
< /*  mz_rs_20050518+ value increased */
< #define MAX_INLINE 20000
---
> /*  mz_rs_20060211+ value increased */
> #define MAX_INLINE 100000
43c43
< /*  mz_rs_20050518- */
---
> /*  mz_rs_20060211- */

diff -r kpp-2.2.3/src/scan.l kpp_rs/src/scan.l
63,64c63,64
<   char crtToken[100];
<   char nextToken[100];
---
>   char crtToken[300];
>   char nextToken[300];
68,69c68,69
<   char crtFile[100];
<   char crt_rate[100];
---
>   char crtFile[300];
>   char crt_rate[300];

diff -r kpp-2.2.3/src/scanutil.c kpp_rs/src/scanutil.c
35c35,38
< #include <malloc.h>
---
> /*  mz_rs_20090904+ */
> /* not necessary, "malloc" comes from <stdlib.h>
> /* #include <malloc.h> */
> /*  mz_rs_20090904- */

diff -r kpp-2.2.3/src/scan.y kpp_rs/src/scan.y
40c40,43
<   #include <malloc.h>
---
>   /*  mz_rs_20090904+ */
>   /* not necessary, "malloc" comes from <stdlib.h>
>   /* #include <malloc.h> */
>   /*  mz_rs_20090904- */
71a75
> /* mz_rs_20070430: value changed from 80 to 300 (must be the same as MAX_K) */
73c77
<   char str[130];
---
>   char str[300];

Seulement dans kpp_rs/src: y.tab.c
Seulement dans kpp_rs/src: y.tab.h

diff -r kpp-2.2.3/util/sutil.f90 kpp_rs/util/sutil.f90
173c173
< 	! subtract all nonzero elements in row i of JVS from X
---
>         ! subtract all nonzero elements in row i of JVS from X
175,176c175,176
< 	  X(LU_ICOL(j)) = X(LU_ICOL(j))-JVS(j)*X(i)
< 	END DO
---
>           X(LU_ICOL(j)) = X(LU_ICOL(j))-JVS(j)*X(i)
>         END DO
180c180
< 	! subtract all nonzero elements in row i of JVS from X
---
>         ! subtract all nonzero elements in row i of JVS from X
182,183c182,183
< 	  X(LU_ICOL(j)) = X(LU_ICOL(j))-JVS(j)*X(i)
< 	END DO
---
>           X(LU_ICOL(j)) = X(LU_ICOL(j))-JVS(j)*X(i)
>         END DO
265c265
< 	! subtract all nonzero elements in row i of JVS from X
---
>         ! subtract all nonzero elements in row i of JVS from X
267,268c267,268
< 	  X(LU_ICOL(j)) = X(LU_ICOL(j))-JVS(j)*X(i)
< 	END DO
---
>           X(LU_ICOL(j)) = X(LU_ICOL(j))-JVS(j)*X(i)
>         END DO
272c272
< 	! subtract all nonzero elements in row i of JVS from X
---
>         ! subtract all nonzero elements in row i of JVS from X
274,275c274,275
< 	  X(LU_ICOL(j)) = X(LU_ICOL(j))-JVS(j)*X(i)
< 	END DO
---
>           X(LU_ICOL(j)) = X(LU_ICOL(j))-JVS(j)*X(i)
>         END DO
298c298
< 	! subtract all nonzero elements in row i of JVS from X
---
>         ! subtract all nonzero elements in row i of JVS from X
300,302c300,302
< 	  XR(LU_ICOL(j)) = XR(LU_ICOL(j))-(JVSR(j)*XR(i) - JVSI(j)*XI(i))
< 	  XI(LU_ICOL(j)) = XI(LU_ICOL(j))-(JVSI(j)*XR(i) + JVSR(j)*XI(i))
< 	END DO
---
>           XR(LU_ICOL(j)) = XR(LU_ICOL(j))-(JVSR(j)*XR(i) - JVSI(j)*XI(i))
>           XI(LU_ICOL(j)) = XI(LU_ICOL(j))-(JVSI(j)*XR(i) + JVSR(j)*XI(i))
>         END DO
306c306
< 	! subtract all nonzero elements in row i of JVS from X
---
>         ! subtract all nonzero elements in row i of JVS from X
308,310c308,310
< 	  XR(LU_ICOL(j)) = XR(LU_ICOL(j))-(JVSR(j)*XR(i) - JVSI(j)*XI(i))
< 	  XI(LU_ICOL(j)) = XI(LU_ICOL(j))-(JVSI(j)*XR(i) + JVSR(j)*XI(i))
< 	END DO
---
>           XR(LU_ICOL(j)) = XR(LU_ICOL(j))-(JVSR(j)*XR(i) - JVSI(j)*XI(i))
>           XI(LU_ICOL(j)) = XI(LU_ICOL(j))-(JVSI(j)*XR(i) + JVSR(j)*XI(i))
>         END DO
390c390
< !	       X(k,i) = X(k,i) - JVS(k,m,j)*X(m,LU_ICOL(j))
---
> !              X(k,i) = X(k,i) - JVS(k,m,j)*X(m,LU_ICOL(j))
402c402
< !	       sum(k) = sum(k) - JVS(k,m,j)*X(m,LU_ICOL(j))
---
> !              sum(k) = sum(k) - JVS(k,m,j)*X(m,LU_ICOL(j))
432c432
< !	  !X(1:3,LU_ICOL(j)) = X(1:3,LU_ICOL(j)) &
---
> !         !X(1:3,LU_ICOL(j)) = X(1:3,LU_ICOL(j)) &
436c436
< !	       X(k,LU_ICOL(j)) = X(k,LU_ICOL(j)) - JVS(m,k,j)*X(m,i)
---
> !              X(k,LU_ICOL(j)) = X(k,LU_ICOL(j)) - JVS(m,k,j)*X(m,i)
439c439
< !	END DO
---
> !       END DO
444c444
< !	  !X(1:3,LU_ICOL(j)) = X(1:3,LU_ICOL(j)) &
---
> !         !X(1:3,LU_ICOL(j)) = X(1:3,LU_ICOL(j)) &
448c448
< !	       X(k,LU_ICOL(j)) = X(k,LU_ICOL(j)) - JVS(m,k,j)*X(m,i)
---
> !              X(k,LU_ICOL(j)) = X(k,LU_ICOL(j)) - JVS(m,k,j)*X(m,i)
451c451
< !	END DO
---
> !       END DO
